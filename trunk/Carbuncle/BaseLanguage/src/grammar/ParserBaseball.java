/* Generated By:JavaCC: Do not edit this line. ParserBaseball.java */
package grammar;

import semantica.ControlloDati;
import semantica.DatiGiocatoreGioco;
import syntaxtree.*;

import java.util.Vector;


public class ParserBaseball implements ParserBaseballConstants {
	static ControlloDati controllo=new ControlloDati();
	static boolean casa = false;
	static int inserimento=2;//lo decremento dopo ogni line up, altrimenti ogni volta che entro in giocatore prova ad inserirmelo in squadra
	static DatiGiocatoreGioco battitoreAttualeCasa;//questi due giocatori mi servono per sapere chi sarà il primo alla battuta nel prox innin
	static DatiGiocatoreGioco battitoreAttualeOspiti;
	static DatiGiocatoreGioco corridoreCasa;
	static DatiGiocatoreGioco corridoreOspiti;
	static int numeroInning=0;
	static boolean attaccoCasa=false;//è true quando la squadra in attacco è quella di casa
	static int numOut=0;
	static int numBattute=0;
	static String tipoLancio=null;
	static String nomeCasa=null;
	static String nomeOspiti=null;
	static int indiceCasa,indiceOspite;
	static Vector<DatiGiocatoreGioco> vectorGiocatoriSulleBasi;
	static Vector<DatiGiocatoreGioco> vectorGiocatoriCasa;//vettore contenente tutti i giocatori di casa con le loro relative statistiche
	static Vector<DatiGiocatoreGioco> vectorGiocatoriOspite;
	static boolean avanzamento;
	static int base;


	static final private void Inizializza(){
		controllo.reset();
		casa=false;
		inserimento=2;
		numeroInning=0;
		attaccoCasa=false;
		numOut=0;
		numBattute=0;
		tipoLancio=null;
		nomeCasa=null;
		nomeOspiti=null;
		battitoreAttualeCasa=null;
		battitoreAttualeOspiti=null;
		indiceCasa=1;//tocca al primo giocatore del lineup casa
		indiceOspite=1;//tocca al primo giocatore del lineup ospiti
		corridoreCasa=null;
		corridoreOspiti=null;
		vectorGiocatoriSulleBasi=new Vector<DatiGiocatoreGioco>();
		vectorGiocatoriSulleBasi.clear();
		vectorGiocatoriCasa=new Vector<DatiGiocatoreGioco>();
		vectorGiocatoriCasa.clear();
		vectorGiocatoriOspite=new Vector<DatiGiocatoreGioco>();
		vectorGiocatoriOspite.clear();
		avanzamento=false;
		base=0;
	}

  static final public S S() throws ParseException {
	  Inizializza();
   SezioneA n0;
   SezioneB n1;
   NodeToken n2;
   Token n3;
   SezioneC n4;
   NodeToken n5;
   Token n6;
    n0 = SezioneA();
    n1 = SezioneB();
    n3 = jj_consume_token(20);
            n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SezioneC();
    n6 = jj_consume_token(21);
            n5 = JTBToolkit.makeNodeToken(n6);

            if(numeroInning<9){throw new ParseException("Una partita di baseball ha almeno 9 inning!");}

            int puntiCasa=0;
            int PuntiOspiti=0;

            System.out.println("statistiche giocatori di "+nomeCasa);
            System.out.println("size di vectorGiocatoriCasa "+vectorGiocatoriCasa.size());
            for(int i=0;i<vectorGiocatoriCasa.size();i++){
            	String nome=vectorGiocatoriCasa.get(i).getName();
            	int num=vectorGiocatoriCasa.get(i).getOrdine();
            	int k=vectorGiocatoriCasa.get(i).getNumeroK();
            	int valide=vectorGiocatoriCasa.get(i).getNumeroValide();
            	int punti=vectorGiocatoriCasa.get(i).getPuntiSegnati();
            	
            	puntiCasa=puntiCasa+punti;
            	
            	System.out.println(nome+" "+num+", numero K= "+k+", numero valide= "+valide+", numero punti= "+punti);
            }
            System.out.println("statistiche giocatori di "+nomeOspiti);
            System.out.println("size di vectorGiocatoriOspiti "+vectorGiocatoriOspite.size());
            for(int i=0;i<vectorGiocatoriOspite.size();i++){
            	String nome=vectorGiocatoriOspite.get(i).getName();
            	int num=vectorGiocatoriOspite.get(i).getOrdine();
            	int k=vectorGiocatoriOspite.get(i).getNumeroK();
            	int valide=vectorGiocatoriOspite.get(i).getNumeroValide();
            	int punti=vectorGiocatoriOspite.get(i).getPuntiSegnati();
            	
            	PuntiOspiti=PuntiOspiti+punti;
            	
            	System.out.println(nome+" "+num+", numero K= "+k+", numero valide= "+valide+", numero punti= "+punti);
            }

            if(puntiCasa==PuntiOspiti){throw new ParseException("Una partita di baseball non può terminare in pareggio, si deve andare agli extra inning!");}

                 {if (true) return new S(n0,n1,n2,n4,n5);}
                throw new Error("Missing return statement in function");
  }

  static final public SezioneA SezioneA() throws ParseException {
   Squadre n0;
   Arbitro n1;
    n0 = Squadre();
    n1 = Arbitro();
     {if (true) return new SezioneA(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  static final public Squadre Squadre() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
    n1 = jj_consume_token(22);
                          n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(NOME);
               n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(23);
            n4 = JTBToolkit.makeNodeToken(n5);
    n7 = jj_consume_token(24);
                        n6 = JTBToolkit.makeNodeToken(n7);
    n9 = jj_consume_token(NOME);
               n8 = JTBToolkit.makeNodeToken(n9);
    n11 = jj_consume_token(25);
             n10 = JTBToolkit.makeNodeToken(n11);
             try {
            	nomeCasa=n2.tokenImage;
            	nomeOspiti=n8.tokenImage;
            } catch (Exception e) {
            	// TODO: handle exception
            }
            
            controllo.setNomeSquadra(nomeCasa,true);
            controllo.setNomeSquadra(nomeOspiti,false);
            if(nomeCasa.equals(nomeOspiti)){throw new ParseException("Le squadre hanno lo stesso nome!");}
            {if (true) return new Squadre(n0,n2,n4,n6,n8,n10);}
             throw new Error("Missing return statement in function");
  }

  static final public Arbitro Arbitro() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(26);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(NOME);
               n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(25);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new Arbitro(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  static final public SezioneB SezioneB() throws ParseException {
   ListaLineUp n0;
    n0 = ListaLineUp();
     {if (true) return new SezioneB(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public ListaLineUp ListaLineUp() throws ParseException {
	  switch (inserimento) {//se inserimento==2 allora questo è il lineup ospite, altrimenti è quello di casa
	  	case 2:
	  		casa=false;
	  		break;
		case 1:
			casa=true;
			break;
		}
   NodeToken n0;
   Token n1;
   LineUp n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   LineUp n7;
   NodeToken n8;
   Token n9;
    n1 = jj_consume_token(27);
                                  n0 = JTBToolkit.makeNodeToken(n1);
    n2 = LineUp();
    n4 = jj_consume_token(25);
            n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(28);
                                n5 = JTBToolkit.makeNodeToken(n6);
    n7 = LineUp();
    n9 = jj_consume_token(25);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new ListaLineUp(n0,n2,n3,n5,n7,n8);}
    throw new Error("Missing return statement in function");
  }

  static final public LineUp LineUp() throws ParseException {
   Giocatore n0;
   NodeToken n1;
   Token n2;
   Giocatore n3;
   NodeToken n4;
   Token n5;
   Giocatore n6;
   NodeToken n7;
   Token n8;
   Giocatore n9;
   NodeToken n10;
   Token n11;
   Giocatore n12;
   NodeToken n13;
   Token n14;
   Giocatore n15;
   NodeToken n16;
   Token n17;
   Giocatore n18;
   NodeToken n19;
   Token n20;
   Giocatore n21;
   NodeToken n22;
   Token n23;
   Giocatore n24;
    n0 = Giocatore();
    n2 = jj_consume_token(23);
            n1 = JTBToolkit.makeNodeToken(n2);
    n3 = Giocatore();
    n5 = jj_consume_token(23);
            n4 = JTBToolkit.makeNodeToken(n5);
    n6 = Giocatore();
    n8 = jj_consume_token(23);
            n7 = JTBToolkit.makeNodeToken(n8);
    n9 = Giocatore();
    n11 = jj_consume_token(23);
             n10 = JTBToolkit.makeNodeToken(n11);
    n12 = Giocatore();
    n14 = jj_consume_token(23);
             n13 = JTBToolkit.makeNodeToken(n14);
    n15 = Giocatore();
    n17 = jj_consume_token(23);
             n16 = JTBToolkit.makeNodeToken(n17);
    n18 = Giocatore();
    n20 = jj_consume_token(23);
             n19 = JTBToolkit.makeNodeToken(n20);
    n21 = Giocatore();
    n23 = jj_consume_token(23);
             n22 = JTBToolkit.makeNodeToken(n23);
    n24 = Giocatore();
    
    inserimento--;
    
     {if (true) return new LineUp(n0,n1,n3,n4,n6,n7,n9,n10,n12,n13,n15,n16,n18,n19,n21,n22,n24);}
    throw new Error("Missing return statement in function");
  }

  static final public Giocatore Giocatore() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(NOME);
               n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(CIFRA_NON_NULLA);
                          n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(POSIZIONE_DIFESA);
                           n4 = JTBToolkit.makeNodeToken(n5);
                           int num=0;
                           try {
                           	num=Integer.parseInt(n3.image);
                           } catch (Exception e) {
                           // TODO: handle exception
                           }
                                                  	
                           String stringa;
                           if(inserimento==1)stringa=nomeCasa;
                           else stringa=nomeOspiti;

                           DatiGiocatoreGioco giocatoreGioco=null;
                           boolean result,flag=true;

                           switch (inserimento) {
                           case 2:
                           	giocatoreGioco=new DatiGiocatoreGioco(stringa,num,n1.toString(),n5.toString());
                           	result=controllo.addSquadra(giocatoreGioco, false);
                           	if(!result)throw new ParseException("I dati del giocatore "+giocatoreGioco.getNome()+" che si vuole inserire sono in contrasto con gli altri della squadra");
                           	for(int i=0;i<vectorGiocatoriOspite.size();i++){
                           		if(vectorGiocatoriOspite.get(i).getName().equals(giocatoreGioco.getName()))flag=false;
                           	}
                           	if(flag){
                           		vectorGiocatoriOspite.add(giocatoreGioco);
                           	}
                           	if(vectorGiocatoriOspite.size()>9){
                           		for(int i=0; i<vectorGiocatoriOspite.size();i++){
                           			System.out.println(vectorGiocatoriOspite.get(i).getName());
                           		}
                           		throw new ParseException("il vettore vectorGiocatoriOspite è più grande di quanto dovrebbe");
                           	}
                           	break;
                           case 1:
                           	giocatoreGioco=new DatiGiocatoreGioco(stringa,num,n1.toString(),n5.toString());
                           	result=controllo.addSquadra(giocatoreGioco, true);
                           	if(!result)throw new ParseException("I dati del giocatore "+giocatoreGioco.getNome()+" che si vuole inserire sono in contrasto con gli altri della squadra");
                           	for(int i=0;i<vectorGiocatoriCasa.size();i++){
                           		if(vectorGiocatoriCasa.get(i).getName().equals(giocatoreGioco.getName()))flag=false;
                           	}
                           	if(flag){
                           		vectorGiocatoriCasa.add(giocatoreGioco);
                           	}
                           	if(vectorGiocatoriCasa.size()>9){
                           		for(int i=0; i<vectorGiocatoriCasa.size();i++){
                           			System.out.println(vectorGiocatoriCasa.get(i).getName());
                           		}
                           		throw new ParseException("il vettore vectorGiocatoriCasa è più grande di quanto dovrebbe");//questo controllo non serve, ci pensa la grammatica
                           	}
                           	break;
                           case 0:
                           	if(!avanzamento){
                           		if(attaccoCasa){
                           			if(indiceCasa>9)indiceCasa=1;
                           			for(int i=0;i<vectorGiocatoriCasa.size();i++)
                           				if(vectorGiocatoriCasa.get(i).getOrdine()==indiceCasa)
                           					battitoreAttualeCasa=vectorGiocatoriCasa.get(i);
                           			System.out.println("battitoreAttualeCasa: "+battitoreAttualeCasa.getName());
                           			}
                           		else{
                           			if(indiceOspite>9)indiceOspite=1;
                           			for(int i=0;i<vectorGiocatoriOspite.size();i++)
                           				if(vectorGiocatoriOspite.get(i).getOrdine()==indiceOspite)
                           					battitoreAttualeOspiti=vectorGiocatoriOspite.get(i);
                           			System.out.println("battitoreAttualeOspiti: "+battitoreAttualeOspiti.getName());
                           			}
                           	}
                           	else{		
                           		if(attaccoCasa){
                           			for(int i=0;i<vectorGiocatoriCasa.size();i++)
                           				if(vectorGiocatoriCasa.get(i).getOrdine()==num)
                           					corridoreCasa=vectorGiocatoriCasa.get(i);	                           				
                           		}
                           		else{
                           			for(int i=0;i<vectorGiocatoriOspite.size();i++)
                           				if(vectorGiocatoriOspite.get(i).getOrdine()==num)
                           					corridoreOspiti=vectorGiocatoriOspite.get(i);			
                           		}		
                           	}
                           	break;
                           }
     {if (true) return new Giocatore(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  static final public SezioneC SezioneC() throws ParseException {
   NodeList n0 = new NodeList();
   Inning n1;
    label_1:
    while (true) {
      n1 = Inning();
        n0.addNode(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 29:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
     n0.nodes.trimToSize();
     {if (true) return new SezioneC(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Inning Inning() throws ParseException {
	  numeroInning++;
	  System.out.println("INNING "+numeroInning);
	  for(int i=0;i<vectorGiocatoriCasa.size();i++){
		  vectorGiocatoriCasa.get(i).setBall(0);
		  vectorGiocatoriCasa.get(i).setStrike(0);
		  vectorGiocatoriCasa.get(i).setBaseAttuale(0);
	  }
	  for(int i=0;i<vectorGiocatoriOspite.size();i++){
		  vectorGiocatoriOspite.get(i).setBall(0);
		  vectorGiocatoriOspite.get(i).setStrike(0);
		  vectorGiocatoriOspite.get(i).setBaseAttuale(0);
	  }
   NodeToken n0;
   Token n1;
   Attacco n2;
   NodeToken n3;
   Token n4;
   Attacco n5;
    n1 = jj_consume_token(29);
                                  n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Attacco();
    n4 = jj_consume_token(30);
                                n3 = JTBToolkit.makeNodeToken(n4);
    n5 = Attacco();
     {if (true) return new Inning(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
  }

  static final public Attacco Attacco() throws ParseException {
	  numOut=0;
		numBattute=0;
		avanzamento=false;
		vectorGiocatoriSulleBasi.clear();
		controllo.azzeraStrikeBall(vectorGiocatoriCasa);
		controllo.azzeraStrikeBall(vectorGiocatoriOspite);
   NodeList n0 = new NodeList();
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   Battuta n4;
   NodeToken n5;
   Token n6;
    label_2:
    while (true) {
        n1 = new NodeSequence(3);
      n3 = jj_consume_token(31);
               n2 = JTBToolkit.makeNodeToken(n3);
        n1.addNode(n2);
      n4 = Battuta();
        n1.addNode(n4);
      n6 = jj_consume_token(32);
               n5 = JTBToolkit.makeNodeToken(n6);
        n1.addNode(n5);
        n0.addNode(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 31:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
    }
     n0.nodes.trimToSize();
     
     if(numBattute<3)throw new ParseException("In ogni attacco ci sono almeno 3 turni di battuta! Errore rilevato nell'inning numero "+numeroInning);
     if(numOut<3)throw new ParseException("Un attacco finisce solo dopo 3 out! Errore rilevato nell'inning numero "+numeroInning);

     if(attaccoCasa)attaccoCasa=false;
     else attaccoCasa=true;
     
     {if (true) return new Attacco(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Battuta Battuta() throws ParseException {
	  numBattute++;
   NodeList n0 = new NodeList();
   Lancio n1;
    label_3:
    while (true) {
      n1 = Lancio();
        n0.addNode(n1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOME:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
    }
     n0.nodes.trimToSize();
     
     if(attaccoCasa){
    		indiceCasa++;
    		if(battitoreAttualeCasa.getBaseAttuale()==0&&battitoreAttualeCasa.getNumeroBall()<4&&battitoreAttualeCasa.getNumeroStrike()<3&&!battitoreAttualeCasa.getPallaBattuta())throw new ParseException("Il turno di battuta del giocatore "+battitoreAttualeCasa.getName()+" nell'inning numero "+numeroInning+" non è ancora finito! palla battuta: "+battitoreAttualeCasa.getPallaBattuta());
    		if(battitoreAttualeCasa.getNumeroBall()>4)throw new ParseException("Il giocatore "+battitoreAttualeCasa.getName()+" non può trovarsi ancora alla battuta visto che ha "+battitoreAttualeCasa.getNumeroBall()+" ball dovrebbe essere in prima base, poblema rilevato nell'inning "+numeroInning);
    		if(battitoreAttualeCasa.getNumeroStrike()>3)throw new ParseException("Il giocatore "+battitoreAttualeCasa.getName()+" non può trovarsi ancora alla battuta visto che ha "+battitoreAttualeCasa.getNumeroStrike()+" strike dovrebbe essere out, poblema rilevato nell'inning "+numeroInning);
    		}
    	else{
    		indiceOspite++;
    	   	if(battitoreAttualeOspiti.getBaseAttuale()==0&&battitoreAttualeOspiti.getNumeroBall()<4&&battitoreAttualeOspiti.getNumeroStrike()<3&&!battitoreAttualeOspiti.getPallaBattuta())throw new ParseException("Il turno di battuta del giocatore "+battitoreAttualeOspiti.getName()+" nell'inning numero "+numeroInning+" non è ancora finito! palla battuta: "+battitoreAttualeOspiti.getPallaBattuta());
    		if(battitoreAttualeOspiti.getNumeroBall()>4)throw new ParseException("Il giocatore "+battitoreAttualeOspiti.getName()+" non può trovarsi ancora alla battuta visto che ha "+battitoreAttualeOspiti.getNumeroBall()+" ball dovrebbe essere in prima base, poblema rilevato nell'inning "+numeroInning);
    		if(battitoreAttualeOspiti.getNumeroStrike()>3)throw new ParseException("Il giocatore "+battitoreAttualeOspiti.getName()+" non può trovarsi ancora alla battuta visto che ha "+battitoreAttualeOspiti.getNumeroStrike()+" strike dovrebbe essere out, poblema rilevato nell'inning "+numeroInning);
    		}
     
     {if (true) return new Battuta(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Lancio Lancio() throws ParseException {
	  avanzamento=false;
   Giocatore n0;
   NodeToken n1;
   Token n2;
   EffettoBattuta n3;
   NodeToken n4;
   Token n5;
    n0 = Giocatore();
    n2 = jj_consume_token(23);
            n1 = JTBToolkit.makeNodeToken(n2);
    n3 = EffettoBattuta();
    n5 = jj_consume_token(25);
            n4 = JTBToolkit.makeNodeToken(n5);
            
            DatiGiocatoreGioco giocatore=null;
            String nome="";
            int num=0;
            String pos="";
            try {
            	nome=n0.f0.tokenImage;
                num=Integer.parseInt(n0.f1.tokenImage);
                pos=n0.f2.tokenImage;
            } catch (Exception e) {
            	// TODO: handle exception
            }

            if(!controllo.controlloNumeroGiocBase(vectorGiocatoriSulleBasi))throw new ParseException("Ci sono più di 3 giocatori sulle basi, problema rilevato nell'inning "+numeroInning);
            if(!controllo.controlloConsistenzaGiocBase(vectorGiocatoriSulleBasi))throw new ParseException("Ci sono più giocatori che condividono la stessa base, problema rilevato nell'inning "+numeroInning);


            giocatore=null;


            if(attaccoCasa){
            	for(int i=0;i<vectorGiocatoriCasa.size();i++){
            		if(vectorGiocatoriCasa.get(i).getName().equals(nome)&&vectorGiocatoriCasa.get(i).getPosizione().equals(pos)&&vectorGiocatoriCasa.get(i).getOrdine()==num)
            			giocatore=vectorGiocatoriCasa.get(i);
            	}
            	if(giocatore==null) throw new ParseException("I dati del giocatore non corrispondono a nessuno dei giocatori in squadra, problema nell'inning "+numeroInning);
            	if(battitoreAttualeCasa.getOrdine()!=giocatore.getOrdine()||!battitoreAttualeCasa.getName().equals(giocatore.getName())||!battitoreAttualeCasa.getPosizione().equals(giocatore.getPosizione()))			
            		throw new ParseException("L'ordine del lineup non è rispettato nell'attacco della squadra di casa! Nell'inning numero "+numeroInning+" tocca al giocatore "+battitoreAttualeCasa.getName()+" "+battitoreAttualeCasa.getOrdine()+", non al giocatore "+giocatore.getNome()+" "+giocatore.getOrdine()+".");
            	}
            else{
            	for(int i=0;i<vectorGiocatoriOspite.size();i++){
            		if(vectorGiocatoriOspite.get(i).getName().equals(nome)&&vectorGiocatoriOspite.get(i).getPosizione().equals(pos)&&vectorGiocatoriOspite.get(i).getOrdine()==num)
            			giocatore=vectorGiocatoriOspite.get(i);
            		}
            	if(giocatore==null) throw new ParseException("I dati del giocatore non corrispondono a nessuno dei giocatori in squadra, problema nell'inning "+numeroInning);
            	if(battitoreAttualeOspiti.getOrdine()!=giocatore.getOrdine()||!battitoreAttualeOspiti.getName().equals(giocatore.getName())||!battitoreAttualeOspiti.getPosizione().equals(giocatore.getPosizione()))
            		throw new ParseException("L'ordine del lineup non è rispettato nell'attacco della squadra di casa! Nell'inning numero "+numeroInning+" tocca al giocatore "+battitoreAttualeOspiti.getName()+" "+battitoreAttualeOspiti.getOrdine()+", non al giocatore "+giocatore.getNome()+" "+giocatore.getOrdine()+".");
            	}

            /////////////////////////
            /*CONTROLLO CHE NON CI SIA UN SUPERAMENTO SULLE BASI*/
            int bas;
            int ordine;
            String nom;
            for(int i=0;i<vectorGiocatoriSulleBasi.size();i++){
            	System.out.println(vectorGiocatoriSulleBasi.get(i).getName()+", base: "+vectorGiocatoriSulleBasi.get(i).getBaseAttuale());
            	bas=vectorGiocatoriSulleBasi.get(i).getBaseAttuale();
            	ordine=vectorGiocatoriSulleBasi.get(i).getOrdine();
            	nom=vectorGiocatoriSulleBasi.get(i).getName();
            	for(int j=i+1;j<vectorGiocatoriSulleBasi.size();j++){
            		if(bas<vectorGiocatoriSulleBasi.get(j).getBaseAttuale()){
            			System.out.println("problema con "+nom+" e "+vectorGiocatoriSulleBasi.get(j).getName()+" aventi rispettivamente base "+bas+" e "+vectorGiocatoriSulleBasi.get(j).getBaseAttuale());
            			throw new ParseException("C'è stato un superamento sulle basi: il giocatore "+vectorGiocatoriSulleBasi.get(j).getName()+" ha superato il giocatore "+nom+" nell'inning "+numeroInning);
            		}
            	}
            }
            /////////////////////////

     {if (true) return new Lancio(n0,n1,n3,n4);}
    throw new Error("Missing return statement in function");
  }

  static final public EffettoBattuta EffettoBattuta() throws ParseException {
   NodeChoice n0;
   PallaBattuta n1;
   PallaNonBattuta n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASE:
    case K:
    case OUT_VOLO:
    case OUT_RUBATA:
    case BASE_SU_BALL:
    case INTERFERENZA:
    case BASE_RUBATA:
    case COLPITO:
    case ERRORE:
    case CIFRA_NON_NULLA:
      n1 = PallaBattuta();
        n0 = new NodeChoice(n1, 0);
      break;
    case TIPO_LANCIO:
      n2 = PallaNonBattuta();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new EffettoBattuta(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public PallaBattuta PallaBattuta() throws ParseException {
		 if(attaccoCasa){
			 battitoreAttualeCasa.setPallaBattuta(true);
			 battitoreAttualeCasa.incApparizioniAlPiatto();///////////////////////////
			 }
		 else {
			 battitoreAttualeOspiti.setPallaBattuta(true);
			 battitoreAttualeOspiti.incApparizioniAlPiatto();/////////////////////////////
		 }
   Esito n0;
   NodeListOptional n1 = new NodeListOptional();
   Avanzamento n2;
    n0 = Esito();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOME:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_4;
      }
      n2 = Avanzamento();
        n1.addNode(n2);
    }
     n1.nodes.trimToSize();
     {if (true) return new PallaBattuta(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  static final public PallaNonBattuta PallaNonBattuta() throws ParseException {
		 if(attaccoCasa){
			 battitoreAttualeCasa.setPallaBattuta(false);
			 battitoreAttualeCasa.incApparizioniAlPiatto();///////////////////////////ad ogni lancio lo incremento, poi se è un BB o un colpito lo decremento
			 }
		 else{
			 battitoreAttualeOspiti.setPallaBattuta(false);
			 battitoreAttualeOspiti.incApparizioniAlPiatto();///////////////////////////ad ogni lancio lo incremento, poi se è un BB o un colpito lo decremento
			 }
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   Esito n3;
   NodeListOptional n4 = new NodeListOptional();
   Avanzamento n5;
    n1 = jj_consume_token(TIPO_LANCIO);
                      n0 = JTBToolkit.makeNodeToken(n1);
                      
                      try {
                    	   	tipoLancio=n0.tokenImage;
                    	} catch (Exception e) {
                    	   // TODO: handle exception
                    	}
                    	if(tipoLancio.equals("BALL")){
                    		if(attaccoCasa)
                    			battitoreAttualeCasa.incNumeroBall();
                    		else
                    			battitoreAttualeOspiti.incNumeroBall();	
                    	}
                    	else{
                    		if(tipoLancio.equals("STRIKE")){
                    			if(attaccoCasa)
                    				battitoreAttualeCasa.incNumeroStrike();			
                    			else
                    				battitoreAttualeOspiti.incNumeroStrike();
                    			}
                    		else{
                    			if(tipoLancio.equals("FOUL BALL")){
                    				System.out.println("FOUL BALL");
                    				if(attaccoCasa){
                    					if(battitoreAttualeCasa.getNumeroStrike()<2){
                    						battitoreAttualeCasa.incNumeroStrike();
                    						}
                    					}		
                    				else{
                    					if(battitoreAttualeOspiti.getNumeroStrike()<2){
                    						battitoreAttualeOspiti.incNumeroStrike();
                    						}
                    					}			
                    			}
                    		}			
                    	}

                    	if(attaccoCasa){
                    		System.out.println(battitoreAttualeCasa.getName()+" num Strike: "+battitoreAttualeCasa.getNumeroStrike()+" num Ball: "+battitoreAttualeCasa.getNumeroBall());
                    	}
                    	else {
                    		System.out.println(battitoreAttualeOspiti.getName()+" num Strike: "+battitoreAttualeOspiti.getNumeroStrike()+" num Ball: "+battitoreAttualeOspiti.getNumeroBall());
                    	}

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASE:
    case K:
    case OUT_VOLO:
    case OUT_RUBATA:
    case BASE_SU_BALL:
    case INTERFERENZA:
    case BASE_RUBATA:
    case COLPITO:
    case ERRORE:
    case CIFRA_NON_NULLA:
      n3 = Esito();
        n2.addNode(n3);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOME:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_5;
      }
      n5 = Avanzamento();
        n4.addNode(n5);
    }
     n4.nodes.trimToSize();
     {if (true) return new PallaNonBattuta(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  static final public Esito Esito() throws ParseException {
   NodeChoice n0;
   ArrivoInBase n1;
   Eliminazione n2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASE:
    case BASE_SU_BALL:
    case INTERFERENZA:
    case BASE_RUBATA:
    case COLPITO:
    case ERRORE:
      n1 = ArrivoInBase();
        n0 = new NodeChoice(n1, 0);
      break;
    case K:
    case OUT_VOLO:
    case OUT_RUBATA:
    case CIFRA_NON_NULLA:
      n2 = Eliminazione();
        n0 = new NodeChoice(n2, 1);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Esito(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Avanzamento Avanzamento() throws ParseException {
	  avanzamento=true;
   Giocatore n0;
   Esito n1;
    n0 = Giocatore();
    n1 = Esito();
     {if (true) return new Avanzamento(n0,n1);}
    throw new Error("Missing return statement in function");
  }

  static final public ArrivoInBase ArrivoInBase() throws ParseException {
   NodeChoice n0;
   Base n1;
   BaseSuBall n2;
   Interferenza n3;
   BaseRubata n4;
   Errore n5;
   Colpito n6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BASE:
      n1 = Base();
        n0 = new NodeChoice(n1, 0);
      break;
    case BASE_SU_BALL:
      n2 = BaseSuBall();
        n0 = new NodeChoice(n2, 1);
      break;
    case INTERFERENZA:
      n3 = Interferenza();
        n0 = new NodeChoice(n3, 2);
      break;
    case BASE_RUBATA:
      n4 = BaseRubata();
        n0 = new NodeChoice(n4, 3);
      break;
    case ERRORE:
      n5 = Errore();
        n0 = new NodeChoice(n5, 4);
      break;
    case COLPITO:
      n6 = Colpito();
        n0 = new NodeChoice(n6, 5);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    
    boolean pallaBattuta;
    if(attaccoCasa)pallaBattuta=battitoreAttualeCasa.getPallaBattuta();
    else pallaBattuta=battitoreAttualeOspiti.getPallaBattuta();


    if(attaccoCasa){
      if(avanzamento){
    	  corridoreCasa.setBaseAttuale(base);
    	  vectorGiocatoriSulleBasi=controllo.aggiungiGiocatoreSuBase(corridoreCasa, vectorGiocatoriSulleBasi);
    	  if(base==4){
    		  corridoreCasa.incPuntiSegnati();
    		  vectorGiocatoriSulleBasi.remove(corridoreCasa);
    	  }
      }
    else{
    	battitoreAttualeCasa.incNumeroValide();
    	battitoreAttualeCasa.setBaseAttuale(base);
    	vectorGiocatoriSulleBasi=controllo.aggiungiGiocatoreSuBase(battitoreAttualeCasa, vectorGiocatoriSulleBasi);
    	  if(base==4){
    		  battitoreAttualeCasa.incPuntiSegnati();
    		  vectorGiocatoriSulleBasi.remove(battitoreAttualeCasa);
    	  }
    	}
    }
    else{
      if(avanzamento){
    	  corridoreOspiti.setBaseAttuale(base);
    	  vectorGiocatoriSulleBasi=controllo.aggiungiGiocatoreSuBase(corridoreOspiti, vectorGiocatoriSulleBasi);
    	  if(base==4){
    		  corridoreOspiti.incPuntiSegnati();
    		  vectorGiocatoriSulleBasi.remove(corridoreOspiti);
    	  }
      }
      else{
    	  battitoreAttualeOspiti.incNumeroValide();
    	  battitoreAttualeOspiti.setBaseAttuale(base);
    	  vectorGiocatoriSulleBasi=controllo.aggiungiGiocatoreSuBase(battitoreAttualeOspiti, vectorGiocatoriSulleBasi);
    	  if(base==4){
    		  battitoreAttualeOspiti.incPuntiSegnati();
    		  vectorGiocatoriSulleBasi.remove(battitoreAttualeOspiti);
    	  }
      }
    }

    System.out.println("SITUAZIONE SULLE BASI:");

    for(int i=0;i<vectorGiocatoriSulleBasi.size();i++){
    		System.out.println(vectorGiocatoriSulleBasi.get(i).getName()+", base: "+vectorGiocatoriSulleBasi.get(i).getBaseAttuale());
    	}

     {if (true) return new ArrivoInBase(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Eliminazione Eliminazione() throws ParseException {
   NodeChoice n0;
   StrikeOut n1;
   OutVolo n2;
   OutSuBase n3;
   OutRubata n4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K:
      n1 = StrikeOut();
        n0 = new NodeChoice(n1, 0);
      break;
    case OUT_VOLO:
      n2 = OutVolo();
        n0 = new NodeChoice(n2, 1);
      break;
    case CIFRA_NON_NULLA:
      n3 = OutSuBase();
        n0 = new NodeChoice(n3, 2);
      break;
    case OUT_RUBATA:
      n4 = OutRubata();
        n0 = new NodeChoice(n4, 3);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new Eliminazione(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Base Base() throws ParseException {
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(BASE);
               n0 = JTBToolkit.makeNodeToken(n1);
               
               String baseLetta=n0.tokenImage;

               if(baseLetta.equals("/")) {
               	base=1;
               	/*
               	if(attaccoCasa)
               		if(battitoreAttualeCasa.getPallaBattuta())battitoreAttualeCasa.incNumeroValide();
               	else 
               		if(battitoreAttualeOspiti.getPallaBattuta())battitoreAttualeOspiti.incNumeroValide();
               	*/
               }
               if(baseLetta.equals("//")) {
               	base=2;    	
               	/*
               	if(attaccoCasa)
               		if(battitoreAttualeCasa.getPallaBattuta())battitoreAttualeCasa.incNumeroValide();
               	else 
               		if(battitoreAttualeOspiti.getPallaBattuta())battitoreAttualeOspiti.incNumeroValide();
               		*/
               }
               if(baseLetta.equals("///")) {
               	base=3;
               	/*
               	if(attaccoCasa)
               		if(battitoreAttualeCasa.getPallaBattuta())battitoreAttualeCasa.incNumeroValide();
               	else 
               		if(battitoreAttualeOspiti.getPallaBattuta())battitoreAttualeOspiti.incNumeroValide();
               	*/
               }
               if(baseLetta.equals("////")){
               	base=4;
               	/*
               	if(attaccoCasa)
               		if(battitoreAttualeCasa.getPallaBattuta())battitoreAttualeCasa.incNumeroValide();
               	else
               		if(battitoreAttualeOspiti.getPallaBattuta())battitoreAttualeOspiti.incNumeroValide();
               		*/
               }
               if(baseLetta.equals("HR")) {
               	base=4;
               	/*
               	if(attaccoCasa)
               		if(battitoreAttualeCasa.getPallaBattuta())battitoreAttualeCasa.incNumeroValide();
               	else
               		if(battitoreAttualeOspiti.getPallaBattuta())battitoreAttualeOspiti.incNumeroValide();
               	*/
               }
     {if (true) return new Base(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public BaseSuBall BaseSuBall() throws ParseException {
	  ///////in caso di base su ball non deve essere conteggiata l'apparizione al piatto, quindi decremento di 4 il numero di apparizioni
	  if(attaccoCasa)battitoreAttualeCasa.decApparizioniAlPiatto(4);
	  else battitoreAttualeOspiti.decApparizioniAlPiatto(4);
	  //////
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(BASE_SU_BALL);
                       n0 = JTBToolkit.makeNodeToken(n1);
                       
                       boolean pallaBattuta;                       
                       if(attaccoCasa){
                       	pallaBattuta=battitoreAttualeCasa.getPallaBattuta();
                       }
                       else{
                       	pallaBattuta=battitoreAttualeOspiti.getPallaBattuta();
                       }

                       base=1;
                       if(pallaBattuta){
                       	throw new ParseException("Non si può andare in base su ball se è stata battuta la palla! Errore nell'inning numero "+numeroInning);
                       }
                       else{
                       	if(attaccoCasa){
                       		if(battitoreAttualeCasa.getNumeroBall()<4){
                       			throw new ParseException("Per andare in base su ball servono almeno 4 ball! Errore nell'inning numero "+numeroInning+", nel turno di battuta del giocatore "+battitoreAttualeCasa.getName()+" che ha solo: "+battitoreAttualeCasa.getNumeroBall()+" ball.");
                       			}
                       		}
                       	  else{
                       		if(battitoreAttualeOspiti.getNumeroBall()<4){
                       			throw new ParseException("Per andare in base su ball servono almeno 4 ball! Errore nell'inning numero "+numeroInning+", nel turno di battuta del giocatore "+battitoreAttualeOspiti.getName()+" che ha solo: "+battitoreAttualeOspiti.getNumeroBall()+" ball.");
                       			}
                       	  }
                         }
     {if (true) return new BaseSuBall(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Colpito Colpito() throws ParseException {
	  ///////nel caso in cui sia colpito non devo tentere conto delle apparizioni al piatto nel turno di battuta corrente
	  if(attaccoCasa){
		  battitoreAttualeCasa.decApparizioniAlPiatto(battitoreAttualeCasa.getNumeroStrike()+battitoreAttualeCasa.getNumeroBall());
		  }
	  else {
		  battitoreAttualeOspiti.decApparizioniAlPiatto(battitoreAttualeOspiti.getNumeroStrike()+battitoreAttualeOspiti.getNumeroBall());
	  }
	  //////
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(COLPITO);
                  n0 = JTBToolkit.makeNodeToken(n1);
                  boolean pallaBattuta;                       
                  if(attaccoCasa)pallaBattuta=battitoreAttualeCasa.getPallaBattuta();
                  else pallaBattuta=battitoreAttualeOspiti.getPallaBattuta();                 

                  base=1;
                  if(pallaBattuta)throw new ParseException("Non si può essere colpiti se si batte la palla! Errore nell'inning numero "+numeroInning);
     {if (true) return new Colpito(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public Interferenza Interferenza() throws ParseException {
///////nel caso in cui sia colpito non devo tentere conto delle apparizioni al piatto nel turno di battuta corrente
	  if(attaccoCasa){
		  battitoreAttualeCasa.decApparizioniAlPiatto(battitoreAttualeCasa.getNumeroStrike()+battitoreAttualeCasa.getNumeroBall());
		  }
	  else {
		  battitoreAttualeOspiti.decApparizioniAlPiatto(battitoreAttualeOspiti.getNumeroStrike()+battitoreAttualeOspiti.getNumeroBall());
	  }
	  //////
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(INTERFERENZA);
                       n0 = JTBToolkit.makeNodeToken(n1);
                       
                       boolean pallaBattuta;                       
                       if(attaccoCasa)pallaBattuta=battitoreAttualeCasa.getPallaBattuta();
                       else pallaBattuta=battitoreAttualeOspiti.getPallaBattuta();

                       base=1;
                       if(pallaBattuta)throw new ParseException("Non si può andare in base a causa di un'interferenza se è stata battuta la palla! Errore nell'inning numero "+numeroInning);                 
                        
     {if (true) return new Interferenza(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public BaseRubata BaseRubata() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(BASE_RUBATA);
                      n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(BASE);
               n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new BaseRubata(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  static final public Errore Errore() throws ParseException {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
    n1 = jj_consume_token(ERRORE);
                 n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(CIFRA_NON_NULLA);
                          n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(BASE);
               n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new Errore(n0,n2,n4);}
    throw new Error("Missing return statement in function");
  }

  static final public StrikeOut StrikeOut() throws ParseException {
	  numOut++;
   NodeToken n0;
   Token n1;
    n1 = jj_consume_token(K);
            n0 = JTBToolkit.makeNodeToken(n1);
            boolean pallaBattuta;                       
            if(attaccoCasa)pallaBattuta=battitoreAttualeCasa.getPallaBattuta();
            else pallaBattuta=battitoreAttualeOspiti.getPallaBattuta();     
                       
                        
            if(pallaBattuta)throw new ParseException("Non si può andare Strike Out se è stata battuta la palla! Errore nell'inning numero "+numeroInning);
            else{	  
            	if(attaccoCasa){
            		battitoreAttualeCasa.incNumeroK();  
                	if(battitoreAttualeCasa.getNumeroStrike()<3)throw new ParseException("Al giocatore "+battitoreAttualeCasa.getName()+", nell'inning numero "+numeroInning+", è stato segnato un K quando non aveva ancora 3 strike, numero Strike: "+battitoreAttualeCasa.getNumeroStrike());
            		}
            	else{
            		battitoreAttualeOspiti.incNumeroK();
            		if(battitoreAttualeOspiti.getNumeroStrike()<3)throw new ParseException("Al giocatore "+battitoreAttualeOspiti.getName()+", nell'inning numero "+numeroInning+", è stato segnato un K quando non aveva ancora 3 strike, numero Strike: "+battitoreAttualeOspiti.getNumeroStrike());
            	}
            }
     {if (true) return new StrikeOut(n0);}
    throw new Error("Missing return statement in function");
  }

  static final public OutVolo OutVolo() throws ParseException {
	  numOut++;
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(OUT_VOLO);
                   n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(CIFRA_NON_NULLA);
                          n2 = JTBToolkit.makeNodeToken(n3);
                          boolean pallaBattuta;                       
                          if(attaccoCasa)pallaBattuta=battitoreAttualeCasa.getPallaBattuta();
                          else pallaBattuta=battitoreAttualeOspiti.getPallaBattuta();

                          if(!pallaBattuta) throw new ParseException("Non ci possono essere eliminazioni al volo se non è stata battuta la palla! Errore nell'inning numero "+numeroInning);
                             
     {if (true) return new OutVolo(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  static final public OutSuBase OutSuBase() throws ParseException {
	  numOut++;
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(CIFRA_NON_NULLA);
                          n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(CIFRA_NON_NULLA);
                          n2 = JTBToolkit.makeNodeToken(n3);
                          boolean pallaBattuta;                       
                          if(attaccoCasa)pallaBattuta=battitoreAttualeCasa.getPallaBattuta();
                          else pallaBattuta=battitoreAttualeOspiti.getPallaBattuta();     

                          if(!pallaBattuta){
                          	throw new ParseException("Il giocatore non può essere eliminato sulle basi visto che non ha battuto! Errore nell'inning numero "+numeroInning);
                          }
                          else{
                          	if(attaccoCasa){
                          	    for(int i=0;i<vectorGiocatoriSulleBasi.size();i++){
                          	 	   if(vectorGiocatoriSulleBasi.get(i).equals(corridoreCasa)){
                          	 		   corridoreCasa.setBaseAttuale(0);
                          	 		   vectorGiocatoriSulleBasi.remove(i);
                          	 		   }
                          	 	   }
                          	 }
                          	 else{
                          	    for(int i=0;i<vectorGiocatoriSulleBasi.size();i++){
                          	       if(vectorGiocatoriSulleBasi.get(i).equals(corridoreOspiti)){
                          	    	   corridoreOspiti.setBaseAttuale(0);
                          	    	   vectorGiocatoriSulleBasi.remove(i);
                          	       	}
                          	      }
                          	 }
                          }
     {if (true) return new OutSuBase(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  static final public OutRubata OutRubata() throws ParseException {
	  numOut++;
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
    n1 = jj_consume_token(OUT_RUBATA);
                     n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(CIFRA_NON_NULLA);
                          n2 = JTBToolkit.makeNodeToken(n3);
                          if(attaccoCasa){
                        	    for(int i=0;i<vectorGiocatoriSulleBasi.size();i++){
                        	 	   if(vectorGiocatoriSulleBasi.get(i).equals(corridoreCasa)){
                        	 		   corridoreCasa.setBaseAttuale(0);
                        	 		   vectorGiocatoriSulleBasi.remove(i);
                        	 		   }
                        	 	   }
                        	 }
                        	 else{
                        	    for(int i=0;i<vectorGiocatoriSulleBasi.size();i++){
                        	       if(vectorGiocatoriSulleBasi.get(i).equals(corridoreOspiti)){
                        	    	   corridoreOspiti.setBaseAttuale(0);
                        	    	   vectorGiocatoriSulleBasi.remove(i);
                        	       }
                        	      }
                        	 }
     {if (true) return new OutRubata(n0,n2);}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public ParserBaseballTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x20000000,0x80000000,0x20000,0xffe0,0x20000,0xbfe0,0x20000,0xbfe0,0x3e20,0x81c0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public ParserBaseball(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ParserBaseball(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserBaseballTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ParserBaseball(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserBaseballTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ParserBaseball(ParserBaseballTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ParserBaseballTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[33];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 33; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }
  //----------------------------------------------------------------------------------------------
	//Metodi per estrarre le statistiche mediante la classe DatiGiocatoreGioco
  	public Vector<DatiGiocatoreGioco>getStatisticheCasa(){
		final Vector<DatiGiocatoreGioco> vettore=new Vector<DatiGiocatoreGioco>(); 
		 for(int i=0;i<vectorGiocatoriCasa.size();i++){
			 vettore.add(vectorGiocatoriCasa.get(i));
		 }
		return vettore;
	}
	public Vector<DatiGiocatoreGioco>getStatisticheOspiti(){
		final Vector<DatiGiocatoreGioco> vettore=new Vector<DatiGiocatoreGioco>(); 
		 for(int i=0;i<vectorGiocatoriOspite.size();i++){
			 vettore.add(vectorGiocatoriOspite.get(i));
		 }
		return vettore;
	}
	public String estraiStringaDaVettore(Vector<DatiGiocatoreGioco> vettore){//mi da le statistiche relative ad una squadra
		String result="Statistiche "+vettore.get(1).getSquadra()+":\n";
		result=result+"Giocatore\tK\tvalide\tpunti\tMB\n";
		for(int i=0;i<vettore.size();i++){
	    	String nome=vettore.get(i).getName();
	    	int voltealpiatto=vettore.get(i).getApparizioniAlPiatto();
	    	int k=vettore.get(i).getNumeroK();
	    	int valide=vettore.get(i).getNumeroValide();
	    	float mb=((float)valide/(float)voltealpiatto)*1000;//calcolo della media battuta per ciascun giocatore
	    	int punti=vettore.get(i).getPuntiSegnati();
	    	result=result+nome+"     \t"+k+"\t"+valide+"\t"+punti+"\t"+(int)mb+"\n";
	    }
		result=result+"\n";
		return result;
	}
	  //----------------------------------------------------------------------------------------------

}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}
